# Практическая работа №6. Работа с контейнерами и алгоритмами STL

**Задание:**

Выберите пользовательский тип согласно варианту из таблицы, либо используйте свой собственный тип, отсутствующий в
таблице.

Вариант для таблицы вычисляем по формуле: **V = (int(c1) + int(c2)) % 8**, где `с1` и `c2` – первая буква в фамилии и
имени на английском языке в верхнем регистре.

| Вариант | Базовый класс |
|---------|---------------|
| 0       | Author        |
| 1       | Book          |
| 2       | Country       |
| 3       | City          |
| 4       | Island        |
| 5       | Language      |
| 6       | Sea           |
| 7       | Football Team |

## Требования:

1. В классе введите по крайней мере **три поля разного типа** (напр., `int`, `string`, `float`).
2. Реализуйте **консольное меню** для возможности работы с коллекцией объектов (добавление, удаление, вывод). В качестве
   коллекции можно использовать контейнер из STL (`vector`, `list`, `stack`, `map` и т.п.).
3. Через консольное меню реализуйте возможность выполнения следующих операций:
    * **Сортировка** элементов (пользователь может выбрать характеристику для сортировки);
    * **Поиск максимального или минимального элемента** по выбранной характеристике объектов (пользователь выбирает
      характеристику);
    * **Вычисление агрегированного значения** (напр., суммарное или среднее значение для выбранной характеристики по
      всем объектам);
    * **Отбор элементов** по заданному условию (пользователь задает пороговое значение для той или иной характеристики);
    * **Поиск элемента** с заданным значением характеристики;
    * **Запись объектов в файл**, **чтение объектов из файла**.

## Технические требования:

* Для реализации операций используйте **алгоритмы STL** (заголовочные файлы `<algorithm>`, `<functional>`): `sort`,
  `min_element`, `transform`, `accumulate`, `for_each`, `find_if`.
* Для настройки алгоритмов задействуйте **лямбда-выражения, функции и функциональные объекты**.
* Для работы с файлами использовать потоковые объекты `ifstream` / `ofstream`.