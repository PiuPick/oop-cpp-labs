# Практическая работа №4. Разработка класса и переопределение операций

В работе необходимо разработать класс для работы с динамической структурой данных. В реализации нельзя использовать
готовые шаблонные классы (vector, map, set и т.п.). Программу необходимо структурировать следующим образом:

- файл с определением класса (имя совпадает с названием структуры данных, например, OrderedSet.h);
- файл с определениями функций-элементов класса (имя совпадает с названием структуры данных, например, OrderedSet.cpp);
- файл с пользовательским меню (source.cpp).

## Задачи

1. Реализовать класс в соответствии с вариантом и в объявлении класса ввести:
    - закрытые поля;
    - конструкторы;
    - деструктор.
2. Реализовать корректное копирование объектов (конструктор копирования, операция присваивания).
3. Реализовать базовую функциональность класса, обозначенную ниже в таблице (функции для добавления\извлечения
   элементов, объединение\пересечение для двух структур данных).
4. Реализовать операторы сравнения для двух структур данных (==, !=, >, <, >=, <=).
5. Реализовать возможность вывода на консоль структур данных через перегрузку оператора сдвига.
6. Через консольное меню реализовать возможность взаимодействия с пользователем и проверки функциональности класса.

## Вариант

`int V = abs(int(c1) * int(c2)) % 6`, где с1 – первая буква фамилии на английском языке в верхнем регистре, с2 – первая
буква имени на английском языке в верхнем регистре.

При реализации необходимо придерживаться предложенных названий и сигнатур, часть функциональности проверяется
автотестами.

## Варианты

### 0. PriorityQueue

Каждый элемент очереди (`int`) характеризуется приоритетом (`int`).  
Извлечение элементов осуществляется с учётом приоритета и порядка: первым извлекается элемент, который имеет наивысший
приоритет; если есть несколько элементов с данным приоритетом, то извлекается элемент, который был добавлен первым.

#### Обязательная функциональность:

```cpp
// добавление элемента с приоритетом
void add(int value, int priority);

// извлечение элемента (с удалением из очереди)
bool get(int& value, int& priority);

// число элементов (всего или с заданным приоритетом)
int count(int priority = 0);

// чтение элемента без удаления из очереди
bool peek(int& value, int& priority);

// Извлечение всех элементов с определенным приоритетом
// элементы копируются в buffer и удаляются из структуры данных
int get(int priority, int*& buffer);

// проверка наличия элемента с учетом приоритета (priority > 0) или без
bool exist(int value, int priority = 0);

// объединение двух очередей (без устранения повторов)
PriorityQueue operator+(const PriorityQueue& other);

// разность двух очередей (элементы с учетом приоритета отсутствуют в other)
PriorityQueue operator-(const PriorityQueue& other);

// пересечение двух приоритетных очередей
// (элементы с учетом приоритета есть в обеих структурах данных)
PriorityQueue operator&(const PriorityQueue& other);

/*
Операторы сравнения двух структур данных:
==, !=, >, <, >=, <=

Сравнение по количеству элементов одного приоритета в обеих структурах.
Если совпадает наибольший приоритет в обеих структурах,
проверяется число элементов наибольшего приоритета;
если совпадает, проверяется следующий приоритет.
*/
```

### 1. PriorityStack

Каждый элемент стека характеризуется приоритетом.
Извлечение элементов осуществляется с учётом приоритета и порядка: первым извлекается элемент, который имеет наивысший
приоритет; если есть несколько элементов с данным приоритетом, то извлекается элемент, который был добавлен последним.

#### Обязательная функциональность:

```cpp
// добавление элемента с приоритетом
void add(int value, int priority);

// извлечение элемента (с удалением из очереди)
bool get(int& value, int& priority);

// число элементов (всего или с заданным приоритетом)
int count(int priority = 0);

// чтение элемента без удаления из очереди
bool peek(int& value, int& priority);

// Извлечение всех элементов с определенным приоритетом
// элементы копируются в buffer и удаляются из структуры данных
int get(int priority, int*& buffer);

// проверка наличия элемента с учетом приоритета (priority > 0) или без
bool contains(int value, int priority = 0);

// объединение двух очередей (без устранения повторов)
PriorityStack operator+(const PriorityStack& other);

// разность двух очередей (элементы с учетом приоритета отсутствуют в other)
PriorityStack operator-(const PriorityStack& other);

// пересечение двух приоритетных очередей
// (элементы с учетом приоритета есть в обеих структурах данных)
PriorityStack operator&(const PriorityStack& other);

/*
Операторы сравнения двух структур данных:
==, !=, >, <, >=, <=

Сравнение по количеству элементов одного приоритета в обеих структурах.
Если совпадает наибольший приоритет в обеих структурах,
проверяется число элементов наибольшего приоритета;
если совпадает, проверяется следующий приоритет.
*/
```

### 2. OrderedSet

Множество содержит уникальные элементы (типа `int`), упорядоченные по убыванию.

#### Обязательная функциональность:

```cpp
// добавление элемента
bool add(int value);

// извлечение наибольшего элемента (с удалением из очереди)
bool get(int& value);

// чтение наибольшего элемента (без удаления из очереди)
bool peek(int& value);

// Извлечение элементов не меньших, чем value
// элементы копируются в buffer (удаляются из множества)
int get(int value, int*& buffer);

// число элементов
int count();

// число элементов не меньших, чем value
int count(int value);

// проверка наличия элемента
bool contains(int value);

// проверка, является ли other подмножеством для текущего множества
bool isSupersetFor(const OrderedSet& other);

// операции объединения (c устранением дублирования элементов)
OrderedSet operator+(const OrderedSet& other);

// разность для двух множеств
OrderedSet operator-(const OrderedSet& other);

// пересечение двух множеств
OrderedSet operator&(const OrderedSet& other);

/*
Операторы сравнения двух структур данных:
==, !=, >, <, >=, <=

Сравнение сначала по размеру,
при равенстве размеров — затем по элементам.
*/
```

### 3. MaxHeap

Элементы хранятся по принципам max-heap:
при представлении структуры в виде двоичного дерева каждый узел содержит значение не меньше, чем значения потомков;
глубина листьев различается не больше, чем на единицу; последний слой дерева заполняется последовательно без пропусков
листьев.

#### Обязательная функциональность:

```cpp
// добавление элемента
bool add(int value);

// извлечение наибольшего элемента (с удалением)
bool get(int& value);

// чтение наибольшего элемента (без удаления)
bool peek(int& value);

// Извлечение элементов равных value
// элементы копируются в buffer (удаляются из структуры данных)
int get(int value, int*& buffer);

// число элементов
int count();

// число элементов равных value
int count(int value);

// проверка наличия элемента
bool contains(int value);

// операции объединения (без исключения повторов)
MaxHeap operator+(const MaxHeap& other);

// разность (элементы не встречаются в other)
MaxHeap operator-(const MaxHeap& other);

// пересечение
// (уникальные элементы, которые есть в обеих структурах данных)
MaxHeap operator&(const MaxHeap& other);

/*
Операторы сравнения двух структур данных:
==, !=, >, <, >=, <=

Сравнение по наибольшему элементу;
если совпадают, то проверяется следующий и т.д.
*/
```

### 4. CircularBuffer

Циклический буфер фиксированного размера. Размер буфера фиксируется в конструкторе при создании.  
После заполнения буфера новый элемент перезаписывает самый старый элемент, который был добавлен раньше остальных.  
Извлекается самый старый элемент.

#### Обязательная функциональность:

```cpp
// добавление элемента
bool add(int value);

// извлечение самого старого элемента (с удалением)
bool get(int& value);

// чтение самого старого (без удаления)
bool peek(int& value);

// извлечение заданного числа самых старых элементов
// возвращается фактическое число извлеченных элементов (не больше, чем count)
// элементы копируются в buffer (удаляются из структуры данных)
int get(int count, int*& buffer);

// число элементов
int count();

// число свободных позиций
int empty();

// проверка наличия элемента
bool contains(int value);

// операции объединения (без исключения повторов)
CircularBuffer operator+(const CircularBuffer& other);

// разность (элементы не встречаются в other)
CircularBuffer operator-(const CircularBuffer& other);

// пересечение
// (уникальные элементы, которые есть в обеих структурах данных)
CircularBuffer operator&(const CircularBuffer& other);

/*
Операторы сравнения двух структур данных:
==, !=, >, <, >=, <=

Сравнение сначала по размеру,
при равенстве размеров сравниваются элементы.
*/
```

### 5. OrderedMap

Каждый элемент характеризуется парой ключ–значение.
Элементы упорядочиваются по ключу (по возрастанию).
Элементы можно извлекать как по ключу, так и по порядку (сначала с наименьшим ключом).

#### Обязательная функциональность:

```cpp
// добавление элемента
void add(int key, int value);

// извлечение элемента с наименьшим ключом (с удалением из структуры данных)
bool get(int& key, int& value);

// чтение элемента без удаления из структуры данных
bool peek(int& key, int& value);

// извлечение элемента по ключу;
// если ключ отсутствует — генерация исключения exception
int get(int key);

// число элементов
int count();

// Извлечение ключей всех элементов с определенным значением
// ключи копируются в buffer и удаляются из структуры данных
int extractKeys(int value, int*& buffer);

// получение всех ключей без удаления элементов из структуры данных
int* keys();

// получение всех значений без удаления элементов из структуры данных
int* values();

// проверка наличия элемента по ключу
bool contains(int key);

// объединение
// при совпадении ключей — генерация исключения exception
OrderedMap operator+(const OrderedMap& other);

// разность (ключи отсутствуют в other)
OrderedMap operator-(const OrderedMap& other);

// пересечение (совпадающие пары ключ–значение)
OrderedMap operator&(const OrderedMap& other);

/*
Операторы сравнения двух структур данных:
==, !=, >, <, >=, <=

Сравнение сначала по размеру,
при равенстве размеров сравниваются элементы
(сначала ключ, затем значение).
*/
```
